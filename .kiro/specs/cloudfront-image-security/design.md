# Design Document: CloudFront Image Security and Performance

## Overview

This design implements a secure, performant, and offline-first image delivery system using AWS CloudFront with Lambda@Edge for on-demand resizing, signed cookie authentication for organization-scoped access control, and TanStack Query for client-side caching and offline support.

The architecture replaces direct public S3 access with a multi-layered approach:
1. **Storage Layer**: Private S3 bucket with organization-scoped keys
2. **CDN Layer**: CloudFront distribution with global edge caching
3. **Processing Layer**: Lambda@Edge for on-demand image resizing using Sharp
4. **Authentication Layer**: Signed cookies generated by Lambda function, validated by CloudFront
5. **Client Layer**: TanStack Query with IndexedDB persistence for offline-first image access

Key benefits:
- **Security**: Organization-scoped access control enforced at multiple layers
- **Performance**: 15-50ms cached delivery from edge locations, <2s uncached
- **Cost**: 93% reduction ($3.60 → $0.27/month for 5k views, <$10/month for 10 users)
- **Offline**: TanStack Query persistence enables app functionality without internet
- **Mobile-Optimized**: WebP thumbnails targeting 50-100KB for fast mobile loading

## Architecture

### High-Level Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Client (Browser)                          │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              TanStack Query + IndexedDB Cache                 │  │
│  │  - Offline-first image queries (networkMode: 'offlineFirst')  │  │
│  │  - 7-day staleTime for thumbnails, 30-day gcTime              │  │
│  │  - Persisted to IndexedDB via createSyncStoragePersister      │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                              ↓ ↑                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    Image Request Flow                         │  │
│  │  1. Check TanStack Query cache (memory + IndexedDB)           │  │
│  │  2. If miss or stale, fetch from CloudFront with cookies      │  │
│  │  3. Store Blob in cache, convert to Object URL for display    │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                              ↓ ↑
┌─────────────────────────────────────────────────────────────────────┐
│                      API Gateway (CWF API)                          │
│  POST /api/images/auth → Cookie Generator Lambda                   │
│  - Validates Cognito token                                          │
│  - Extracts organization_id from token claims                       │
│  - Generates CloudFront signed cookies with policy:                 │
│    Resource: https://cdn.example.com/organizations/{org_id}/*       │
│    Expires: now + 1 hour                                            │
│  - Returns Set-Cookie headers (Policy, Signature, Key-Pair-Id)      │
└─────────────────────────────────────────────────────────────────────┘
                              ↓ ↑
┌─────────────────────────────────────────────────────────────────────┐
│                    CloudFront Distribution                          │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              Edge Location (Global Cache)                     │  │
│  │  1. Validate signed cookies against policy                    │  │
│  │  2. Check cache for requested image + query params            │  │
│  │  3. If cache hit: return cached image (15-50ms)               │  │
│  │  4. If cache miss: invoke Lambda@Edge                         │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                              ↓ ↑                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │         Lambda@Edge (Image Resizer - us-east-1)               │  │
│  │  - Parse query params (width, height, quality, format)        │  │
│  │  - Fetch original from S3 via Origin Access Identity          │  │
│  │  - Resize using Sharp library                                 │  │
│  │  - Convert to WebP by default for thumbnails                  │  │
│  │  - Target 50-100KB for mobile thumbnails                      │  │
│  │  - Return resized image to CloudFront for caching             │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                              ↓ ↑
┌─────────────────────────────────────────────────────────────────────┐
│                    S3 Bucket (cwf-dev-assets)                       │
│  - Private bucket (no public access)                                │
│  - Origin Access Identity grants CloudFront read access             │
│  - Organization-scoped keys:                                        │
│    organizations/{org_id}/images/{timestamp}-{random}-{filename}    │
└─────────────────────────────────────────────────────────────────────┘
```

### Request Flow Examples

**First-time thumbnail request (cold cache):**
1. User opens page with 100 action photos
2. Frontend calls `getImageUrl(s3Key, {width: 200, quality: 75, format: 'webp'})`
3. TanStack Query checks cache (miss) → fetches from CloudFront
4. CloudFront validates signed cookies → cache miss → invokes Lambda@Edge
5. Lambda@Edge fetches original from S3, resizes to 200px WebP at 75% quality (~60KB)
6. CloudFront caches resized image at edge location (24hr TTL)
7. TanStack Query stores Blob in memory cache + persists to IndexedDB
8. Total time: ~1.5s per image (parallel requests)

**Subsequent thumbnail request (warm cache):**
1. User returns to same page next day
2. TanStack Query checks cache (hit, <7 days old) → serves from IndexedDB
3. No network request, instant display
4. Total time: <10ms

**Thumbnail request from different device (CloudFront cached):**
1. User opens page on different device
2. TanStack Query checks cache (miss) → fetches from CloudFront
3. CloudFront validates cookies → cache hit at edge location
4. Returns cached image
5. Total time: 15-50ms

**Offline request:**
1. User opens app without internet
2. TanStack Query checks cache (hit) → serves from IndexedDB
3. Displays offline indicator badge
4. Total time: <10ms

## Components and Interfaces

### 1. Cookie Generator Lambda (cwf-image-auth)

**Purpose**: Generate CloudFront signed cookies after validating user authentication and organization membership.

**Runtime**: Node.js 18.x  
**Memory**: 256 MB  
**Timeout**: 10 seconds  
**Region**: us-west-2 (same as API Gateway)

**Environment Variables**:
- `CLOUDFRONT_DOMAIN`: CloudFront distribution domain (e.g., d1234567890.cloudfront.net)
- `CLOUDFRONT_KEY_PAIR_ID`: CloudFront public key ID for signed URLs
- `CLOUDFRONT_PRIVATE_KEY_SECRET_NAME`: AWS Secrets Manager secret containing private key
- `COOKIE_EXPIRATION_SECONDS`: Cookie expiration time (default: 3600 = 1 hour)

**Input** (API Gateway event):
```typescript
{
  headers: {
    Authorization: "Bearer <cognito-jwt-token>"
  },
  requestContext: {
    authorizer: {
      claims: {
        sub: "user-uuid",
        "custom:organization_id": "org-uuid",
        email: "user@example.com"
      }
    }
  }
}
```

**Output** (API Gateway response):
```typescript
{
  statusCode: 200,
  headers: {
    "Set-Cookie": [
      "CloudFront-Policy=<base64-policy>; Domain=.cloudfront.net; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=3600",
      "CloudFront-Signature=<signature>; Domain=.cloudfront.net; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=3600",
      "CloudFront-Key-Pair-Id=<key-pair-id>; Domain=.cloudfront.net; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=3600"
    ]
  },
  body: JSON.stringify({
    success: true,
    expiresAt: "2024-01-15T12:00:00Z"
  })
}
```

**CloudFront Policy Structure**:
```json
{
  "Statement": [
    {
      "Resource": "https://d1234567890.cloudfront.net/organizations/<org_id>/*",
      "Condition": {
        "DateLessThan": {
          "AWS:EpochTime": 1705320000
        }
      }
    }
  ]
}
```

**Implementation Logic**:
1. Extract Cognito token from Authorization header
2. Validate token is present (API Gateway authorizer already validated it)
3. Extract organization_id from `requestContext.authorizer.claims['custom:organization_id']`
4. Fetch CloudFront private key from AWS Secrets Manager
5. Build CloudFront policy with organization-scoped resource path
6. Sign policy using RSA-SHA1 with private key
7. Base64-encode policy and signature
8. Return Set-Cookie headers with all three required cookies

**Error Handling**:
- Missing organization_id → 400 Bad Request
- Secrets Manager fetch failure → 500 Internal Server Error
- Signing failure → 500 Internal Server Error

### 2. Lambda@Edge Image Resizer

**Purpose**: On-demand image resizing and format conversion at CloudFront edge locations.

**Runtime**: Node.js 18.x  
**Memory**: 512 MB (Sharp requires more memory for image processing)  
**Timeout**: 5 seconds  
**Region**: us-east-1 (Lambda@Edge requirement)  
**Trigger**: CloudFront origin-request event

**Dependencies**:
- `sharp`: Image processing library (must be compiled for Lambda environment)
- AWS SDK v3 (S3 client)

**Input** (CloudFront origin-request event):
```typescript
{
  Records: [{
    cf: {
      request: {
        uri: "/organizations/org-123/images/1705320000-abc123-photo.jpg",
        querystring: "width=200&quality=75&format=webp",
        headers: {
          host: [{ value: "d1234567890.cloudfront.net" }]
        }
      },
      config: {
        distributionDomainName: "d1234567890.cloudfront.net"
      }
    }
  }]
}
```

**Output** (CloudFront response):
```typescript
{
  status: "200",
  statusDescription: "OK",
  headers: {
    "content-type": [{ value: "image/webp" }],
    "cache-control": [{ value: "public, max-age=86400" }],
    "content-length": [{ value: "62000" }]
  },
  body: "<base64-encoded-image>",
  bodyEncoding: "base64"
}
```

**Implementation Logic**:
1. Parse query parameters from `request.querystring`
   - `width`: Target width in pixels (optional)
   - `height`: Target height in pixels (optional)
   - `quality`: JPEG/WebP quality 1-100 (default: 80)
   - `format`: Output format (jpeg, png, webp) (default: webp for thumbnails)
2. Extract S3 key from `request.uri` (remove leading slash)
3. Validate S3 key matches organization-scoped pattern
4. Fetch original image from S3 using Origin Access Identity credentials
5. Process image with Sharp:
   ```javascript
   let pipeline = sharp(s3Buffer);
   
   if (width || height) {
     pipeline = pipeline.resize(width, height, {
       fit: 'inside',  // Maintain aspect ratio
       withoutEnlargement: true  // Don't upscale
     });
   }
   
   // Convert format
   if (format === 'webp') {
     pipeline = pipeline.webp({ quality });
   } else if (format === 'jpeg') {
     pipeline = pipeline.jpeg({ quality });
   } else if (format === 'png') {
     pipeline = pipeline.png({ quality });
   }
   
   const buffer = await pipeline.toBuffer();
   ```
6. Base64-encode processed image
7. Return response with appropriate headers for CloudFront caching

**Optimization Strategies**:
- For thumbnails (width ≤ 300): Default to WebP at 75% quality
- For previews (width ≤ 1000): Default to WebP at 85% quality
- For full-size: Preserve original format unless explicitly requested
- Set Cache-Control: max-age=86400 (24 hours) for all resized images
- Use Sharp's `withoutEnlargement` to avoid upscaling small images

**Error Handling**:
- Invalid query params → Return original image (no resize)
- S3 fetch failure → 404 Not Found
- Sharp processing failure → 500 Internal Server Error (log to CloudWatch)
- Timeout → Return original image if possible, else 504 Gateway Timeout

### 3. CloudFront Distribution Configuration

**Purpose**: Global CDN for secure, fast image delivery with signed cookie authentication.

**Configuration**:
```yaml
Origin:
  DomainName: cwf-dev-assets.s3.us-west-2.amazonaws.com
  OriginAccessIdentity: origin-access-identity/cloudfront/E1234567890ABC
  
Behaviors:
  PathPattern: /organizations/*
  ViewerProtocolPolicy: https-only
  AllowedMethods: [GET, HEAD, OPTIONS]
  CachedMethods: [GET, HEAD]
  Compress: true
  
  TrustedSigners:
    Enabled: true
    KeyPairIds: [<cloudfront-key-pair-id>]
  
  LambdaFunctionAssociations:
    - EventType: origin-request
      LambdaFunctionARN: arn:aws:lambda:us-east-1:account:function:image-resizer:version
  
  CachePolicy:
    MinTTL: 86400  # 24 hours
    MaxTTL: 31536000  # 1 year
    DefaultTTL: 86400  # 24 hours
    
    ParametersInCacheKey:
      QueryStringsConfig:
        QueryStringBehavior: whitelist
        QueryStrings: [width, height, quality, format]
      HeadersConfig:
        HeaderBehavior: none
      CookiesConfig:
        CookieBehavior: none  # Signed cookies not included in cache key
  
  ResponseHeadersPolicy:
    SecurityHeaders:
      StrictTransportSecurity:
        Override: true
        AccessControlMaxAgeSec: 31536000
        IncludeSubdomains: true
      ContentTypeOptions:
        Override: true
```

**Cache Key Strategy**:
- Include query parameters (width, height, quality, format) in cache key
- Exclude signed cookies from cache key (same resized image shared across users in same org)
- This means: `image.jpg?width=200&format=webp` is cached once per edge location, served to all authenticated users

**Security Headers**:
- HSTS: Force HTTPS for 1 year
- X-Content-Type-Options: nosniff

### 4. S3 Bucket Configuration

**Purpose**: Private storage for organization-scoped images.

**Bucket Policy** (remove all public access):
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowCloudFrontOAI",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity E1234567890ABC"
      },
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::cwf-dev-assets/*"
    }
  ]
}
```

**Key Structure**:
- Old: `mission-attachments/uploads/{timestamp}-{random}-{filename}`
- New: `organizations/{org_id}/images/{timestamp}-{random}-{filename}`

**Migration Strategy**:
1. Identify organization_id for each existing image by querying database
2. Copy images to new keys (S3 CopyObject API)
3. Update database records with new keys
4. Verify all images accessible via CloudFront
5. Delete old keys after 30-day grace period

### 5. Frontend Image Hook (useImage)

**Purpose**: TanStack Query hook for fetching, caching, and displaying images with offline support.

**Interface**:
```typescript
interface UseImageOptions {
  width?: number;
  height?: number;
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
  enabled?: boolean;
}

interface UseImageResult {
  imageUrl: string | null;  // Object URL for display
  isLoading: boolean;
  isError: boolean;
  isOffline: boolean;  // True if served from cache while offline
  refetch: () => void;
}

function useImage(
  s3Key: string | null | undefined,
  options?: UseImageOptions
): UseImageResult;
```

**Implementation**:
```typescript
import { useQuery } from '@tanstack/react-query';
import { getCloudFrontUrl } from '@/lib/imageService';

export function useImage(
  s3Key: string | null | undefined,
  options: UseImageOptions = {}
): UseImageResult {
  const { width, height, quality = 80, format = 'webp', enabled = true } = options;
  
  const query = useQuery({
    queryKey: ['image', s3Key, width, height, quality, format],
    queryFn: async () => {
      if (!s3Key) throw new Error('No S3 key provided');
      
      const url = getCloudFrontUrl(s3Key, { width, height, quality, format });
      
      // Fetch image as Blob
      const response = await fetch(url, {
        credentials: 'include',  // Include signed cookies
      });
      
      if (!response.ok) {
        if (response.status === 403) {
          // Cookie expired, trigger refresh
          await refreshImageCookies();
          // Retry once
          const retryResponse = await fetch(url, { credentials: 'include' });
          if (!retryResponse.ok) throw new Error('Image fetch failed after cookie refresh');
          return await retryResponse.blob();
        }
        throw new Error(`Image fetch failed: ${response.status}`);
      }
      
      return await response.blob();
    },
    enabled: enabled && !!s3Key,
    staleTime: width && width <= 300 ? 7 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000,  // 7 days for thumbnails, 1 day for larger
    gcTime: 30 * 24 * 60 * 60 * 1000,  // 30 days
    networkMode: 'offlineFirst',  // Check cache first, even when online
    retry: 1,
  });
  
  // Convert Blob to Object URL for display
  const imageUrl = query.data ? URL.createObjectURL(query.data) : null;
  
  // Cleanup Object URL on unmount
  useEffect(() => {
    return () => {
      if (imageUrl) URL.revokeObjectURL(imageUrl);
    };
  }, [imageUrl]);
  
  return {
    imageUrl,
    isLoading: query.isLoading,
    isError: query.isError,
    isOffline: query.isStale && !navigator.onLine,
    refetch: query.refetch,
  };
}
```

**TanStack Query Persistence Setup** (in main.tsx or App.tsx):
```typescript
import { QueryClient } from '@tanstack/react-query';
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client';
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 30 * 24 * 60 * 60 * 1000,  // 30 days
    },
  },
});

const persister = createSyncStoragePersister({
  storage: window.localStorage,  // Or use IndexedDB for larger storage
  key: 'cwf-image-cache',
});

// In App component:
<PersistQueryClientProvider
  client={queryClient}
  persistOptions={{ persister }}
>
  {/* App content */}
</PersistQueryClientProvider>
```

**Note**: For storing Blobs in IndexedDB (larger capacity than localStorage), use `createAsyncStoragePersister` with a custom IndexedDB adapter:
```typescript
import { del, get, set } from 'idb-keyval';

const persister = createAsyncStoragePersister({
  storage: {
    getItem: async (key) => await get(key),
    setItem: async (key, value) => await set(key, value),
    removeItem: async (key) => await del(key),
  },
  key: 'cwf-image-cache',
});
```

### 6. Image Service Module

**Purpose**: Centralized utilities for image URL construction and cookie management.

**Interface**:
```typescript
interface ImageUrlOptions {
  width?: number;
  height?: number;
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
}

// Construct CloudFront URL from S3 key
export function getCloudFrontUrl(
  s3Key: string,
  options?: ImageUrlOptions
): string;

// Request signed cookies from API
export async function refreshImageCookies(): Promise<void>;

// Check if cookies are expired or expiring soon
export function areCookiesExpiringSoon(): boolean;

// Clear image cookies on logout
export function clearImageCookies(): void;
```

**Implementation**:
```typescript
const CLOUDFRONT_DOMAIN = import.meta.env.VITE_CLOUDFRONT_DOMAIN;
const COOKIE_REFRESH_THRESHOLD = 5 * 60 * 1000;  // 5 minutes

let cookieExpiresAt: number | null = null;

export function getCloudFrontUrl(
  s3Key: string,
  options: ImageUrlOptions = {}
): string {
  // Handle legacy full URLs (backward compatibility during migration)
  if (s3Key.startsWith('http')) {
    // Extract key from full S3 URL
    const url = new URL(s3Key);
    s3Key = url.pathname.substring(1);  // Remove leading slash
  }
  
  // Construct CloudFront URL
  const url = new URL(`https://${CLOUDFRONT_DOMAIN}/${s3Key}`);
  
  // Add query parameters
  if (options.width) url.searchParams.set('width', options.width.toString());
  if (options.height) url.searchParams.set('height', options.height.toString());
  if (options.quality) url.searchParams.set('quality', options.quality.toString());
  if (options.format) url.searchParams.set('format', options.format);
  
  return url.toString();
}

export async function refreshImageCookies(): Promise<void> {
  const response = await fetch(`${import.meta.env.VITE_API_BASE_URL}/api/images/auth`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${getAuthToken()}`,  // From existing auth service
    },
    credentials: 'include',
  });
  
  if (!response.ok) {
    throw new Error('Failed to refresh image cookies');
  }
  
  const data = await response.json();
  cookieExpiresAt = new Date(data.expiresAt).getTime();
}

export function areCookiesExpiringSoon(): boolean {
  if (!cookieExpiresAt) return true;
  return Date.now() + COOKIE_REFRESH_THRESHOLD >= cookieExpiresAt;
}

export function clearImageCookies(): void {
  cookieExpiresAt = null;
  // Cookies are HttpOnly, so they're cleared by server on logout
}
```

### 7. Presigned Upload Lambda Updates

**Purpose**: Update existing cwf-presigned-upload Lambda to use organization-scoped UUID-based keys.

**Changes Required**:
1. Extract organization_id from Cognito token claims
2. Change S3 key pattern from `mission-attachments/uploads/{timestamp}-{random}-{filename}` to `organizations/{org_id}/images/{uuid}.{extension}`
3. Use crypto.randomUUID() for guaranteed uniqueness
4. Return S3 key (not full URL) in response
5. Preserve original filename for database storage

**Updated Response**:
```typescript
{
  uploadUrl: "https://cwf-dev-assets.s3.us-west-2.amazonaws.com/...",  // Presigned URL for upload
  s3Key: "organizations/org-123/images/a3f5b8c9-d2e1-f4a7-b6c5-d8e9f1a2b3c4.jpg",  // Store this in DB
  originalFilename: "banana-plant-photo.jpg",  // Store this in image_metadata table
  expiresAt: "2024-01-15T12:05:00Z"
}
```

**Key Structure Rationale**:
- **UUID-based**: Fast generation (<1ms), guaranteed unique, no collisions
- **No timestamp**: Avoids slow hashing, simpler than content-based deduplication
- **Flat structure**: `images/` folder, not subfolders by type (database tracks relationships)
- **Extension preserved**: Allows CloudFront to set correct Content-Type headers

### 8. EXIF Metadata Extraction Lambda

**Purpose**: Automatically extract EXIF metadata (GPS, timestamp, camera info) from uploaded images and store in database for querying and analysis.

**Runtime**: Node.js 18.x  
**Memory**: 512 MB (Sharp requires memory for image processing)  
**Timeout**: 30 seconds  
**Region**: us-west-2  
**Trigger**: S3 event on `organizations/*/images/*` prefix

**Dependencies**:
- `sharp`: Image processing library with EXIF parsing
- `pg`: PostgreSQL client for database writes

**Input** (S3 event):
```typescript
{
  Records: [{
    s3: {
      bucket: { name: "cwf-dev-assets" },
      object: { 
        key: "organizations/org-123/images/a3f5b8c9-d2e1-f4a7-b6c5-d8e9f1a2b3c4.jpg",
        size: 2458624
      }
    }
  }]
}
```

**Implementation Logic**:
```javascript
import sharp from 'sharp';
import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import pg from 'pg';

export const handler = async (event) => {
  const s3Key = event.Records[0].s3.object.key;
  const fileSize = event.Records[0].s3.object.size;
  
  // Extract organization_id from key
  const orgId = s3Key.split('/')[1];
  
  // Fetch image from S3
  const s3 = new S3Client({ region: 'us-west-2' });
  const { Body, ContentType } = await s3.send(new GetObjectCommand({
    Bucket: 'cwf-dev-assets',
    Key: s3Key
  }));
  
  const buffer = Buffer.from(await Body.transformToByteArray());
  
  // Extract EXIF metadata using Sharp
  const metadata = await sharp(buffer).metadata();
  
  // Parse GPS coordinates (convert from DMS to decimal degrees)
  let gpsLat = null, gpsLon = null, gpsAlt = null;
  if (metadata.exif) {
    const exif = parseExif(metadata.exif);
    if (exif.GPSLatitude && exif.GPSLongitude) {
      gpsLat = convertDMSToDecimal(exif.GPSLatitude, exif.GPSLatitudeRef);
      gpsLon = convertDMSToDecimal(exif.GPSLongitude, exif.GPSLongitudeRef);
      gpsAlt = exif.GPSAltitude || null;
    }
  }
  
  // Parse capture timestamp
  const capturedAt = metadata.exif?.DateTimeOriginal 
    ? parseExifDate(metadata.exif.DateTimeOriginal)
    : null;
  
  // Store in database
  const db = new pg.Pool({ /* RDS connection */ });
  await db.query(`
    INSERT INTO image_metadata (
      s3_key, organization_id, file_size_bytes, mime_type,
      gps_latitude, gps_longitude, gps_altitude,
      captured_at, camera_make, camera_model,
      original_width, original_height, orientation,
      exif_extracted_at
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW())
    ON CONFLICT (s3_key) DO UPDATE SET
      gps_latitude = EXCLUDED.gps_latitude,
      gps_longitude = EXCLUDED.gps_longitude,
      gps_altitude = EXCLUDED.gps_altitude,
      captured_at = EXCLUDED.captured_at,
      exif_extracted_at = NOW()
  `, [
    s3Key, orgId, fileSize, ContentType,
    gpsLat, gpsLon, gpsAlt,
    capturedAt, metadata.exif?.Make, metadata.exif?.Model,
    metadata.width, metadata.height, metadata.orientation
  ]);
  
  console.log(`EXIF extracted for ${s3Key}:`, {
    gps: gpsLat && gpsLon ? `${gpsLat}, ${gpsLon}` : 'none',
    capturedAt: capturedAt || 'none',
    dimensions: `${metadata.width}x${metadata.height}`
  });
};

// Helper: Convert EXIF DMS (degrees, minutes, seconds) to decimal degrees
function convertDMSToDecimal(dms, ref) {
  const [degrees, minutes, seconds] = dms;
  let decimal = degrees + minutes / 60 + seconds / 3600;
  if (ref === 'S' || ref === 'W') decimal *= -1;
  return decimal;
}

// Helper: Parse EXIF date format (YYYY:MM:DD HH:MM:SS) to ISO timestamp
function parseExifDate(exifDate) {
  const [date, time] = exifDate.split(' ');
  const [year, month, day] = date.split(':');
  return new Date(`${year}-${month}-${day}T${time}`).toISOString();
}
```

**Error Handling**:
- **No EXIF data**: Store NULL values, log info message (not error)
- **Corrupted image**: Log error, skip metadata extraction, don't fail
- **Database write failure**: Retry once, then log error and alert
- **S3 fetch failure**: Retry with exponential backoff, then fail

**Metadata Extracted**:
- **GPS Coordinates**: Latitude, longitude, altitude (critical for farm mapping!)
- **Capture Timestamp**: When photo was actually taken (vs upload time)
- **Camera Info**: Make, model (useful for quality analysis)
- **Dimensions**: Original width/height before resizing
- **Orientation**: EXIF orientation flag (1-8)
- **File Info**: Size, MIME type

**Use Cases**:
1. **Farm Mapping**: Plot all action photos on a map by GPS coordinates
2. **Timeline Analysis**: Show photos by actual capture time, not upload time
3. **Quality Tracking**: Identify low-quality images by dimensions/camera
4. **Duplicate Detection**: Find images with same GPS + timestamp (likely duplicates)
5. **Offline Sync**: Know when photo was taken even if uploaded days later

### 9. Image Metadata Database Schema

**Purpose**: Update existing cwf-presigned-upload Lambda to use organization-scoped keys.

**Changes Required**:
1. Extract organization_id from Cognito token claims
2. Change S3 key pattern from `mission-attachments/uploads/{timestamp}-{random}-{filename}` to `organizations/{org_id}/images/{timestamp}-{random}-{filename}`
3. Return S3 key (not full URL) in response

**Updated Response**:
```typescript
{
  uploadUrl: "https://cwf-dev-assets.s3.us-west-2.amazonaws.com/...",  // Presigned URL for upload
  s3Key: "organizations/org-123/images/1705320000-abc123-photo.jpg",  // Store this in DB
  expiresAt: "2024-01-15T12:05:00Z"
}
```

## Data Models

### Database Schema Changes

**No new tables required.** Existing image URL fields will store S3 keys instead of full URLs.

**Migration Script** (SQL):
```sql
-- Extract S3 keys from full URLs
-- Pattern: https://cwf-dev-assets.s3.us-west-2.amazonaws.com/{key}

-- state_photos table
UPDATE state_photos
SET photo_url = regexp_replace(
  photo_url,
  '^https://cwf-dev-assets\.s3\.us-west-2\.amazonaws\.com/',
  ''
)
WHERE photo_url LIKE 'https://cwf-dev-assets.s3.us-west-2.amazonaws.com/%';

-- parts table
UPDATE parts
SET image_url = regexp_replace(
  image_url,
  '^https://cwf-dev-assets\.s3\.us-west-2\.amazonaws\.com/',
  ''
)
WHERE image_url LIKE 'https://cwf-dev-assets.s3.us-west-2.amazonaws.com/%';

-- tools table
UPDATE tools
SET image_url = regexp_replace(
  image_url,
  '^https://cwf-dev-assets\.s3\.us-west-2\.amazonaws\.com/',
  ''
)
WHERE image_url LIKE 'https://cwf-dev-assets.s3.us-west-2.amazonaws.com/%';

-- issues table (JSONB array)
UPDATE issues
SET report_photo_urls = (
  SELECT jsonb_agg(
    regexp_replace(
      url::text,
      '^"https://cwf-dev-assets\.s3\.us-west-2\.amazonaws\.com/',
      '"'
    )::jsonb
  )
  FROM jsonb_array_elements(report_photo_urls) AS url
)
WHERE report_photo_urls::text LIKE '%https://cwf-dev-assets.s3.us-west-2.amazonaws.com/%';
```

### TanStack Query Cache Structure

**Query Key Format**:
```typescript
['image', s3Key, width, height, quality, format]
```

**Examples**:
- `['image', 'organizations/org-123/images/photo.jpg', 200, undefined, 75, 'webp']`
- `['image', 'organizations/org-123/images/photo.jpg', undefined, undefined, 80, 'webp']`

**Cached Data**:
- Type: `Blob`
- Metadata: Stored in query state (fetchedAt, staleTime, etc.)

**Persistence**:
- Storage: IndexedDB (via idb-keyval)
- Key: `cwf-image-cache`
- Value: Serialized TanStack Query cache (includes Blobs)
- Max Size: Browser-dependent (typically 50MB-1GB for IndexedDB)

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Cookie Generation Properties

Property 1: Valid authentication produces complete signed cookies  
*For any* valid Cognito token with organization_id claim, the Cookie_Generator should return all three required cookies (CloudFront-Policy, CloudFront-Signature, CloudFront-Key-Pair-Id) with correct attributes (HttpOnly, Secure, SameSite=Strict)  
**Validates: Requirements 2.3, 2.5, 6.4, 6.5, 6.6**

Property 2: Cookie policy restricts access to organization path  
*For any* generated signed cookie, the CloudFront policy resource path should contain only the user's organization_id, preventing access to other organizations' images  
**Validates: Requirements 2.4, 3.3, 18.4**

Property 3: Invalid authentication is rejected  
*For any* request with missing or invalid Cognito token, the Cookie_Generator should return 401 Unauthorized and not generate cookies  
**Validates: Requirements 2.1, 2.2**

### S3 Key Generation Properties

Property 4: Upload keys follow organization-scoped pattern  
*For any* presigned URL generation request, the returned S3 key should match the pattern `organizations/{org_id}/images/{timestamp}-{random}-{filename}` where org_id matches the authenticated user's organization  
**Validates: Requirements 3.1, 3.2, 12.1, 12.2, 12.3**

Property 5: Database stores keys not URLs  
*For any* image upload, the value stored in the database should be an S3 key (not a full URL), enabling dynamic CloudFront URL construction  
**Validates: Requirements 8.1, 8.2, 8.3, 8.4, 12.4**

### Image Resizing Properties

Property 6: Resize maintains aspect ratio  
*For any* image and target dimensions (width or height), the resized output should maintain the original aspect ratio (output_width/output_height = input_width/input_height, within rounding tolerance)  
**Validates: Requirements 5.2**

Property 7: Format conversion produces correct output format  
*For any* image and target format (jpeg, png, webp), the resized output should be in the requested format (verified by MIME type and file signature)  
**Validates: Requirements 5.4**

Property 8: Quality parameter affects compression  
*For any* image and quality values Q1 < Q2, the output file size at Q1 should be less than or equal to the output file size at Q2 (lower quality = smaller file)  
**Validates: Requirements 5.3**

Property 9: Supported input formats are processed successfully  
*For any* image in supported formats (JPEG, PNG, WebP, HEIC, PDF), the Image_Resizer should successfully process and return a resized image without errors  
**Validates: Requirements 5.6**

Property 10: Thumbnail size optimization  
*For any* thumbnail request (width ≤ 300), the output file size should be between 30KB and 150KB when using WebP format at 75% quality, balancing quality and bandwidth  
**Validates: Requirements 5.10, 15.5**

### URL Construction Properties

Property 11: CloudFront URL construction from S3 keys  
*For any* S3 key, the getCloudFrontUrl helper should produce a valid HTTPS CloudFront URL with the key as the path component  
**Validates: Requirements 10.2, 18.5**

Property 12: Resize options appear in query string  
*For any* resize options (width, height, quality, format), the constructed CloudFront URL should include these as query parameters  
**Validates: Requirements 10.3, 10.4**

Property 13: Backward compatibility with legacy URLs  
*For any* input that is either an S3 key or a full S3 URL, the getCloudFrontUrl helper should correctly extract the key and construct a valid CloudFront URL  
**Validates: Requirements 10.6, 13.1, 13.2, 13.3**

### Caching and Offline Properties

Property 14: Cache-first image serving  
*For any* image request where the image exists in TanStack Query cache and is not stale, the system should serve the image from cache without making a network request  
**Validates: Requirements 19.4**

Property 15: Offline image availability  
*For any* cached image, when the device is offline (navigator.onLine = false), the system should serve the image from persisted cache and display an offline indicator  
**Validates: Requirements 19.7, 19.9**

Property 16: Blob storage in cache  
*For any* successfully fetched image, the TanStack Query cache should store the image as a Blob with associated metadata (s3Key, dimensions, format)  
**Validates: Requirements 19.3**

### Error Handling Properties

Property 17: Cookie refresh on 403 errors  
*For any* image request that returns 403 Forbidden, the system should attempt to refresh cookies once and retry the request before showing an error  
**Validates: Requirements 16.2**

Property 18: Placeholder on error  
*For any* image request that fails after retry, the system should display a placeholder image instead of breaking the UI  
**Validates: Requirements 16.1**

Property 19: Error logging  
*For any* authentication error or image resize error, the system should log the error to CloudWatch with relevant context (user_id, org_id, s3_key, error_message)  
**Validates: Requirements 16.4**

### Security Properties

Property 20: Direct S3 access is denied  
*For any* attempt to access an S3 object directly via S3 URL (not through CloudFront), the S3 bucket should return 403 Forbidden  
**Validates: Requirements 1.3, 1.4, 18.1**

Property 21: Cross-organization access is denied  
*For any* user with signed cookies for organization A, attempts to access images from organization B should be denied by CloudFront with 403 Forbidden  
**Validates: Requirements 3.4, 18.3**

Property 22: Expired cookies are rejected  
*For any* signed cookie past its expiration time, CloudFront should reject the request and return 403 Forbidden  
**Validates: Requirements 2.7, 18.2**

## Error Handling

### Lambda Function Errors

**Cookie Generator Lambda**:
- **Missing organization_id**: Return 400 Bad Request with error message
- **Secrets Manager failure**: Return 500 Internal Server Error, log to CloudWatch
- **Signing failure**: Return 500 Internal Server Error, log error details
- **All errors**: Include correlation ID for debugging

**Lambda@Edge Image Resizer**:
- **Invalid query parameters**: Ignore invalid params, use defaults
- **S3 fetch failure**: Return 404 Not Found if object doesn't exist
- **Sharp processing failure**: Log error, attempt to return original image
- **Timeout (>5s)**: Return 504 Gateway Timeout, log slow processing
- **Memory limit**: Increase Lambda memory or return original image
- **All errors**: Log to CloudWatch with s3Key, params, error details

### Frontend Errors

**Image Fetch Errors**:
- **403 Forbidden**: Attempt cookie refresh once, retry request
- **404 Not Found**: Display placeholder image, log missing image
- **Network error**: Check cache, serve from cache if available
- **Timeout**: Display loading state, retry with exponential backoff

**Cookie Refresh Errors**:
- **401 Unauthorized**: Redirect to login (session expired)
- **Network error**: Continue with existing cookies if not expired
- **500 Server Error**: Retry once, then show error message

**Cache Errors**:
- **IndexedDB quota exceeded**: Evict oldest images (LRU), retry
- **IndexedDB unavailable**: Fall back to memory-only cache
- **Serialization error**: Log error, skip caching for that image

### CloudFront Errors

**Origin Errors**:
- **S3 unavailable**: Serve from CloudFront cache if available
- **Lambda@Edge timeout**: Return 504, client should retry
- **Lambda@Edge error**: Return 500, log to CloudWatch

**Authentication Errors**:
- **Missing cookies**: Return 403 with error page
- **Invalid signature**: Return 403, client should refresh cookies
- **Expired cookies**: Return 403, client should refresh cookies

### Monitoring and Alerting

**CloudWatch Metrics**:
- Cookie generation success/failure rate
- Image resize processing time (p50, p95, p99)
- CloudFront cache hit ratio
- 403 error rate (should be <1% in steady state)
- Lambda@Edge error rate

**Alerts**:
- 403 error rate >5% for 5 minutes → Page on-call
- Cookie generation failure rate >10% → Page on-call
- Lambda@Edge error rate >5% → Investigate
- Average resize time >3s → Investigate performance

## Testing Strategy

### Dual Testing Approach

This system requires both unit tests and property-based tests for comprehensive coverage:

**Unit Tests**: Verify specific examples, edge cases, and integration points
- Specific cookie generation scenarios (valid token, missing org_id, expired token)
- Specific image resize scenarios (JPEG to WebP, maintain aspect ratio)
- Frontend component behavior (display placeholder on error, show offline indicator)
- Integration between components (cookie refresh flow, upload flow)

**Property-Based Tests**: Verify universal properties across all inputs
- Cookie generation for any valid token produces valid cookies
- Image resizing for any image and dimensions maintains aspect ratio
- URL construction for any S3 key produces valid CloudFront URLs
- Cache behavior for any image follows cache-first pattern

Together, these approaches provide comprehensive coverage: unit tests catch concrete bugs in specific scenarios, while property-based tests verify general correctness across the input space.

### Property-Based Testing Configuration

**Library**: fast-check (JavaScript/TypeScript property-based testing library)

**Configuration**:
- Minimum 100 iterations per property test (due to randomization)
- Each test tagged with feature name and property number
- Tag format: `Feature: cloudfront-image-security, Property {N}: {property_text}`

**Example Property Test**:
```typescript
import fc from 'fast-check';
import { describe, it, expect } from 'vitest';
import { getCloudFrontUrl } from '@/lib/imageService';

describe('Property 11: CloudFront URL construction from S3 keys', () => {
  it('Feature: cloudfront-image-security, Property 11: For any S3 key, produces valid HTTPS CloudFront URL', () => {
    fc.assert(
      fc.property(
        // Generator: S3 keys matching organization-scoped pattern
        fc.tuple(
          fc.uuid(),  // org_id
          fc.integer({ min: 1000000000, max: 9999999999 }),  // timestamp
          fc.hexaString({ minLength: 6, maxLength: 6 }),  // random
          fc.stringOf(fc.constantFrom('a', 'b', 'c', '1', '2', '3'), { minLength: 5, maxLength: 20 })  // filename
        ).map(([orgId, timestamp, random, filename]) => 
          `organizations/${orgId}/images/${timestamp}-${random}-${filename}.jpg`
        ),
        (s3Key) => {
          const url = getCloudFrontUrl(s3Key);
          
          // Property: URL should be valid HTTPS CloudFront URL
          expect(url).toMatch(/^https:\/\//);
          expect(url).toContain(process.env.VITE_CLOUDFRONT_DOMAIN);
          expect(url).toContain(s3Key);
        }
      ),
      { numRuns: 100 }
    );
  });
});
```

### Unit Testing Strategy

**Backend (Lambda Functions)**:
- Test cookie generation with various token scenarios
- Test S3 key pattern generation
- Test image resizing with sample images
- Test error handling (missing params, invalid tokens)
- Mock AWS services (S3, Secrets Manager, CloudWatch)

**Frontend (React Components)**:
- Test useImage hook with mocked TanStack Query
- Test getCloudFrontUrl helper with various inputs
- Test cookie refresh flow
- Test offline indicator display
- Test placeholder display on errors
- Use React Testing Library for component tests

**Integration Tests**:
- Test end-to-end flow: authenticate → get cookies → fetch image
- Test upload flow: generate presigned URL → upload → verify key in DB
- Test migration: old URL → extract key → fetch via CloudFront
- Use Playwright or Cypress for E2E tests

### Test Coverage Goals

- **Backend Lambda Functions**: >80% line coverage
- **Frontend Hooks and Services**: >90% line coverage
- **Frontend Components**: >70% line coverage
- **Property Tests**: All 22 correctness properties implemented
- **Integration Tests**: All critical user flows covered

### Testing Environments

**Local Development**:
- Mock AWS services using LocalStack or AWS SDK mocks
- Use Vitest for unit and property tests
- Use Playwright for E2E tests against local dev server

**CI/CD Pipeline**:
- Run all unit tests on every commit
- Run property tests on every commit (100 iterations each)
- Run integration tests on every PR
- Deploy to staging environment for manual testing

**Staging Environment**:
- Real CloudFront distribution (separate from production)
- Real S3 bucket (separate from production)
- Real Cognito user pool (test users only)
- Manual testing of upload/download flows
- Performance testing with realistic image sizes

### Migration Testing

**Pre-Migration**:
- Verify all existing images accessible via S3 URLs
- Backup database image URL fields
- Test migration script on copy of production data

**During Migration**:
- Test backward compatibility (both URL formats work)
- Verify CloudFront serves migrated images correctly
- Monitor error rates and performance

**Post-Migration**:
- Verify all images accessible via CloudFront
- Verify direct S3 access returns 403
- Verify cross-org access is denied
- Performance testing (cache hit ratio, load times)
- Cost monitoring (CloudFront + Lambda@Edge costs)

