const { Client } = require('pg');
const { randomUUID } = require('crypto');
const { getAuthorizerContext, buildOrganizationFilter, hasPermission, canAccessOrganization } = require('./shared/authorizerContext');

// Database configuration
// SECURITY: Password must be provided via environment variable
// Never hardcode passwords in source code
if (!process.env.DB_PASSWORD) {
  throw new Error('DB_PASSWORD environment variable is required');
}

const dbConfig = {
  host: process.env.DB_HOST || 'cwf-dev-postgres.ctmma86ykgeb.us-west-2.rds.amazonaws.com',
  port: parseInt(process.env.DB_PORT || '5432', 10),
  database: process.env.DB_NAME || 'postgres',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD,
  ssl: {
    rejectUnauthorized: false
  }
};

const escapeLiteral = (value = '') => String(value).replace(/'/g, "''");

const formatSqlValue = (value) => {
  if (value === null || value === undefined) return 'NULL';
  if (typeof value === 'number') return value;
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  if (Array.isArray(value)) {
    if (value.length === 0) return 'ARRAY[]::text[]';
    const sanitizedItems = value.map((item) => `'${escapeLiteral(String(item))}'`);
    return `ARRAY[${sanitizedItems.join(', ')}]`;
  }
  if (typeof value === 'object') {
    return `'${escapeLiteral(JSON.stringify(value))}'::jsonb`;
  }
  return `'${escapeLiteral(String(value))}'`;
};

const buildUpdateClauses = (body, allowedFields) => {
  return allowedFields.reduce((clauses, field) => {
    if (Object.prototype.hasOwnProperty.call(body, field)) {
      clauses.push(`${field} = ${formatSqlValue(body[field])}`);
    }
    return clauses;
  }, []);
};

// Helper to execute SQL and return JSON
async function queryJSON(sql) {
  const client = new Client(dbConfig);
  try {
    await client.connect();
    const result = await client.query(sql);
    return result.rows;
  } catch (error) {
    console.error('Database query error:', error);
    throw error;
  } finally {
    await client.end();
  }
}



exports.handler = async (event) => {
  console.log('Event:', JSON.stringify(event, null, 2));
  
  const { httpMethod, path } = event;
  
  // CORS headers (define early for error responses)
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type,Authorization',
    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
  };
  
  // Handle preflight OPTIONS requests FIRST, before any authorizer context extraction
  // OPTIONS requests don't go through the authorizer and may not have requestContext.authorizer
  if (httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: ''
    };
  }
  
  // Extract authorizer context (organization_id, permissions, etc.)
  const authContext = getAuthorizerContext(event);
  const organizationId = authContext.organization_id;
  const hasDataReadAll = hasPermission(authContext, 'data:read:all');
  
  // Log error if organization_id is missing - don't use fallback to hide problems
  if (!organizationId) {
    console.error('❌ ERROR: organization_id is missing from authorizer context!');
    console.error('   This indicates a problem with the Lambda authorizer configuration.');
    console.error('   Authorizer context:', JSON.stringify(authContext, null, 2));
    console.error('   Event requestContext:', JSON.stringify(event.requestContext, null, 2));
  }
  
  // Set accessibleOrgIds from authContext (may be empty for some endpoints like profiles)
  const accessibleOrgIds = authContext.accessible_organization_ids || [];
  
  console.log('Authorizer context:', {
    organization_id: organizationId || 'MISSING',
    accessible_orgs: accessibleOrgIds,
    accessible_orgs_count: accessibleOrgIds.length,
    has_data_read_all: hasDataReadAll,
    permissions: authContext.permissions
  });
  
  try {
    // CORS headers already defined above

    // Health check endpoint
    if (httpMethod === 'GET' && path.endsWith('/health')) {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ status: 'ok', timestamp: new Date().toISOString() })
      };
    }

    // Schema endpoint
    if (httpMethod === 'GET' && path.endsWith('/schema')) {
      const schema = {
        version: 1,
        tables: {
          actions: ['id', 'title', 'description', 'assigned_to', 'status', 'created_at', 'updated_at'],
          tools: ['id', 'name', 'description', 'category', 'status', 'serial_number', 'storage_location'],
          parts: ['id', 'name', 'description', 'category', 'current_quantity', 'minimum_quantity'],
          organization_members: ['user_id', 'full_name', 'role'],
          missions: ['id', 'title', 'description', 'created_by', 'created_at', 'updated_at']
        },
        last_updated: Date.now()
      };
      
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify(schema)
      };
    }

    // Tools endpoint
    if (path.match(/\/tools\/[a-f0-9-]+$/)) {
      const toolId = path.split('/').pop();
      if (httpMethod === 'GET') {
        const sql = `SELECT * FROM tools WHERE id = '${toolId}' LIMIT 1`;
        const result = await queryJSON(sql);
        return { statusCode: result?.[0] ? 200 : 404, headers, body: JSON.stringify({ data: result?.[0] || null }) };
      }
      if (httpMethod === 'PUT') {
        const toolId = path.split('/').pop();
        const body = JSON.parse(event.body || '{}');
        const updates = buildUpdateClauses(body, [
          'status',
          'actual_location',
          'storage_location',
          'legacy_storage_vicinity',
          'name',
          'description',
          'category',
          'serial_number',
          'accountable_person_id',
          'image_url'
        ]);
        if (updates.length === 0) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'No fields to update' })
          };
        }
        updates.push('updated_at = NOW()');
        const sql = `UPDATE tools SET ${updates.join(', ')} WHERE id = '${toolId}' RETURNING *`;
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
      
      if (httpMethod === 'GET') {
        const { limit = 50, offset = 0 } = event.queryStringParameters || {};
        const sql = `SELECT json_agg(row_to_json(result)) FROM (
          SELECT DISTINCT ON (tools.id)
            tools.*,
            CASE 
              WHEN active_checkouts.id IS NOT NULL THEN 'checked_out'
              ELSE tools.status
            END as status,
            CASE WHEN tools.image_url LIKE '%supabase.co%' THEN 
              REPLACE(
                tools.image_url, 
                'https://oskwnlhuuxjfuwnjuavn.supabase.co/storage/v1/object/public/', 
                'https://cwf-dev-assets.s3.us-west-2.amazonaws.com/'
              )
            ELSE tools.image_url 
            END as image_url,
            CASE WHEN active_checkouts.id IS NOT NULL THEN true ELSE false END as is_checked_out,
            active_checkouts.user_id as checked_out_user_id,
            active_checkouts.user_name as checked_out_to,
            active_checkouts.checkout_date as checked_out_date,
            active_checkouts.expected_return_date,
            active_checkouts.intended_usage as checkout_intended_usage,
            active_checkouts.notes as checkout_notes
          FROM tools
          LEFT JOIN LATERAL (
            SELECT * FROM checkouts
            WHERE checkouts.tool_id = tools.id
              AND checkouts.is_returned = false
            ORDER BY checkouts.checkout_date DESC NULLS LAST, checkouts.created_at DESC
            LIMIT 1
          ) active_checkouts ON true
          ORDER BY tools.id, tools.name 
          LIMIT ${limit} OFFSET ${offset}
        ) result;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }
    }

    // Parts endpoint
    // PUT /parts/{id} - Update part (check this first before the GET /parts)
    if (httpMethod === 'PUT' && path.match(/\/parts\/[^/]+$/)) {
      const partId = path.split('/').pop();
      const body = JSON.parse(event.body || '{}');
      
      const updates = [];
      if (body.current_quantity !== undefined) {
        updates.push(`current_quantity = ${body.current_quantity}`);
      }
      if (body.name !== undefined) {
        updates.push(`name = ${formatSqlValue(body.name)}`);
      }
      if (body.description !== undefined) {
        updates.push(`description = ${formatSqlValue(body.description)}`);
      }
      if (body.category !== undefined) {
        updates.push(`category = ${formatSqlValue(body.category)}`);
      }
      if (body.minimum_quantity !== undefined) {
        updates.push(`minimum_quantity = ${body.minimum_quantity}`);
      }
      if (body.storage_location !== undefined) {
        updates.push(`storage_location = ${formatSqlValue(body.storage_location)}`);
      }
      if (body.image_url !== undefined) {
        updates.push(`image_url = ${formatSqlValue(body.image_url)}`);
      }
      
      if (updates.length === 0) {
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ error: 'No fields to update' })
        };
      }
      
      updates.push('updated_at = NOW()');
      
      const sql = `
        UPDATE parts 
        SET ${updates.join(', ')} 
        WHERE id = '${escapeLiteral(partId)}'
        RETURNING *;
      `;
      
      const result = await queryJSON(sql);
      if (!result || result.length === 0 || !result[0]) {
        return {
          statusCode: 404,
          headers,
          body: JSON.stringify({ error: 'Not found' })
        };
      }
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ data: result[0] })
      };
    }
    
    // GET /parts - List parts
    if (path.endsWith('/parts') && httpMethod === 'GET') {
      const { limit = 50, offset = 0 } = event.queryStringParameters || {};
      const sql = `SELECT json_agg(row_to_json(t)) FROM (
        SELECT id, name, description, category, current_quantity, minimum_quantity, 
               unit, parent_structure_id, storage_location, legacy_storage_vicinity, 
               accountable_person_id, 
               CASE 
                 WHEN image_url LIKE '%supabase.co%' THEN 
                   REPLACE(image_url, 'https://oskwnlhuuxjfuwnjuavn.supabase.co/storage/v1/object/public/', 'https://cwf-dev-assets.s3.us-west-2.amazonaws.com/')
                 ELSE image_url 
               END as image_url,
               created_at, updated_at 
        FROM parts ORDER BY name LIMIT ${limit} OFFSET ${offset}
      ) t;`;
      
      const result = await queryJSON(sql);
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
      };
    }
    
    // Parts history endpoint
    if (path.endsWith('/parts_history')) {
      if (httpMethod === 'GET') {
        const { part_id, organization_id, change_type, changed_by, limit = 100 } = event.queryStringParameters || {};
        let whereConditions = [];
        
        if (part_id) {
          // Cast both sides to ensure type compatibility
          // If part_id column is UUID, cast the parameter. If it's TEXT, cast the column.
          // Try casting the parameter first: 'value'::uuid
          whereConditions.push(`ph.part_id::text = '${escapeLiteral(part_id)}'`);
        }
        if (organization_id) {
          whereConditions.push(`ph.organization_id::text = '${escapeLiteral(organization_id)}'`);
        }
        if (change_type) {
          whereConditions.push(`ph.change_type = '${escapeLiteral(change_type)}'`);
        }
        if (changed_by) {
          whereConditions.push(`ph.changed_by = '${escapeLiteral(changed_by)}'`);
        }
        
        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
        const limitClause = `LIMIT ${parseInt(limit)}`;
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT 
            ph.*,
            COALESCE(om.full_name, ph.changed_by::text) as changed_by_name
          FROM parts_history ph
          LEFT JOIN organization_members om ON ph.changed_by::text = om.cognito_user_id::text
          ${whereClause} ORDER BY ph.changed_at DESC ${limitClause}
        ) t;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }
      
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const { part_id, change_type, old_quantity, new_quantity, quantity_change, change_reason } = body;
        
        if (!part_id || change_type === undefined || old_quantity === undefined || new_quantity === undefined) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'part_id, change_type, old_quantity, and new_quantity are required' })
          };
        }
        
        if (!organizationId) {
          console.error('❌ ERROR: Cannot create parts_history entry - organization_id is missing from authorizer context');
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Server configuration error: organization context not available' })
          };
        }
        
        const userId = authContext.cognito_user_id;
        if (!userId) {
          console.error('❌ ERROR: Cannot create parts_history entry - cognito_user_id is missing from authorizer context');
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Server configuration error: user context not available' })
          };
        }
        
        const sql = `
          INSERT INTO parts_history (
            part_id, change_type, old_quantity, new_quantity, quantity_change, 
            changed_by, change_reason, organization_id, changed_at, created_at
          )
          VALUES (
            ${formatSqlValue(part_id)},
            ${formatSqlValue(change_type)},
            ${old_quantity},
            ${new_quantity},
            ${quantity_change !== undefined ? quantity_change : 'NULL'},
            ${formatSqlValue(userId)},
            ${formatSqlValue(change_reason)},
            ${formatSqlValue(organizationId)},
            NOW(),
            NOW()
          )
          RETURNING *;
        `;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
    }

    // Issues collection endpoint
    if (path.endsWith('/issues')) {
      if (httpMethod === 'GET') {
        const { context_type, context_id, status } = event.queryStringParameters || {};
        let whereConditions = [];
        if (context_type) whereConditions.push(`context_type = '${context_type}'`);
        if (context_id) whereConditions.push(`context_id = '${escapeLiteral(context_id)}'`);
        if (status) {
          if (status.includes(',')) {
            const statuses = status.split(',').map(s => `'${s}'`).join(',');
            whereConditions.push(`status IN (${statuses})`);
          } else {
            whereConditions.push(`status = '${status}'`);
          }
        }
        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT * FROM issues ${whereClause} ORDER BY reported_at DESC
        ) t;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }

      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const requiredFields = ['context_id', 'description', 'reported_by'];
        const missing = requiredFields.filter(field => !body[field]);
        if (missing.length > 0) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: `Missing required fields: ${missing.join(', ')}` })
          };
        }

        // Always use organizationId from authorizer context (not from request body)
        if (!organizationId) {
          console.error('❌ ERROR: Cannot create issue - organization_id is missing from authorizer context');
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Server configuration error: organization context not available' })
          };
        }
        const orgId = organizationId;

        const insertData = {
          context_type: body.context_type || 'tool',
          context_id: body.context_id,
          description: body.description,
          issue_type: body.issue_type || 'general',
          status: body.status || 'active',
          workflow_status: body.workflow_status || 'reported',
          reported_by: body.reported_by,
          organization_id: orgId,
          related_checkout_id: body.related_checkout_id || null,
          report_photo_urls: body.report_photo_urls || [],
          issue_metadata: body.issue_metadata || {},
          damage_assessment: body.damage_assessment || null,
          efficiency_loss_percentage: body.efficiency_loss_percentage ?? null,
          is_misuse: body.is_misuse ?? false,
          responsibility_assigned: body.responsibility_assigned ?? false,
          can_self_claim: body.can_self_claim ?? false,
          ready_to_work: body.ready_to_work ?? false,
          next_steps: body.next_steps || null,
          action_required: body.action_required || null,
          assigned_to: body.assigned_to || null,
          materials_needed: body.materials_needed || null,
          work_progress: body.work_progress || null,
          ai_analysis: body.ai_analysis || null
        };

        const columns = Object.keys(insertData);
        const values = columns.map((column) => formatSqlValue(insertData[column]));

        const sql = `
          INSERT INTO issues (${columns.join(', ')}, created_at, reported_at, updated_at)
          VALUES (${values.join(', ')}, NOW(), NOW(), NOW())
          RETURNING *;
        `;

        const result = await queryJSON(sql);
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
    }

    // Individual issue endpoint
    if (path.match(/\/issues\/[a-f0-9-]+$/)) {
      const issueId = path.split('/').pop();

      if (httpMethod === 'GET') {
        const sql = `SELECT * FROM issues WHERE id = '${issueId}' LIMIT 1;`;
        const result = await queryJSON(sql);
        return {
          statusCode: result?.length ? 200 : 404,
          headers,
          body: JSON.stringify(result?.length ? { data: result[0] } : { error: 'Issue not found' })
        };
      }

      if (httpMethod === 'PUT') {
        const body = JSON.parse(event.body || '{}');
        const updates = buildUpdateClauses(body, [
          'status',
          'workflow_status',
          'root_cause',
          'resolution_notes',
          'resolution_photo_urls',
          'issue_metadata',
          'damage_assessment',
          'report_photo_urls',
          'related_checkout_id',
          'description',
          'issue_type',
          'assigned_to',
          'ready_to_work',
          'responsibility_assigned',
          'action_required',
          'next_steps',
          'materials_needed',
          'work_progress',
          'ai_analysis',
          'actual_hours',
          'estimated_hours',
          'efficiency_loss_percentage',
          'is_misuse',
          'can_self_claim',
          'context_id',
          'context_type',
          'reported_by',
          'resolved_at',
          'resolved_by'
        ]);

        if (updates.length === 0) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'No fields to update' })
          };
        }

        updates.push('updated_at = NOW()');

        const sql = `UPDATE issues SET ${updates.join(', ')} WHERE id = '${issueId}' RETURNING *`;
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
    }

    // Issue history logging
    if (path.endsWith('/issue_history') && httpMethod === 'POST') {
      const body = JSON.parse(event.body || '{}');
      const { issue_id, new_status } = body;
      if (!issue_id || !new_status) {
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ error: 'issue_id and new_status are required' })
        };
      }

      // Always use organizationId from authorizer context (not from request body)
      if (!organizationId) {
        console.error('❌ ERROR: Cannot create issue history - organization_id is missing from authorizer context');
        return {
          statusCode: 500,
          headers,
          body: JSON.stringify({ error: 'Server configuration error: organization context not available' })
        };
      }
      const orgId = organizationId;
      const changedBy = body.changed_by ? escapeLiteral(body.changed_by) : 'system';
      const oldStatus = body.old_status ? `'${escapeLiteral(body.old_status)}'` : 'NULL';
      const notes = body.notes ? `'${escapeLiteral(body.notes)}'` : 'NULL';

      const sql = `
        INSERT INTO issue_history (issue_id, old_status, new_status, notes, organization_id, changed_by, changed_at, created_at)
        VALUES ('${issue_id}', ${oldStatus}, '${escapeLiteral(new_status)}', ${notes}, '${orgId}', '${changedBy}', NOW(), NOW())
        RETURNING *;
      `;

      const result = await queryJSON(sql);
      return {
        statusCode: 201,
        headers,
        body: JSON.stringify({ data: result[0] })
      };
    }

    // Parts orders endpoint
    if (httpMethod === 'GET' && path.endsWith('/parts_orders')) {
      const { status } = event.queryStringParameters || {};
      let whereClause = '';
      if (status) {
        if (status.includes(',')) {
          const statuses = status.split(',').map(s => `'${s}'`).join(',');
          whereClause = `WHERE status IN (${statuses})`;
        } else {
          whereClause = `WHERE status = '${status}'`;
        }
      }
      
      const sql = `SELECT json_agg(row_to_json(t)) FROM (
        SELECT * FROM parts_orders ${whereClause} ORDER BY ordered_at DESC
      ) t;`;
      
      const result = await queryJSON(sql);
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
      };
    }

    // Organization members endpoint
    if (path.endsWith('/organization_members')) {
      if (httpMethod === 'GET') {
        const { cognito_user_id } = event.queryStringParameters || {};
        let whereClause = cognito_user_id ? `WHERE cognito_user_id = '${cognito_user_id}'` : '';
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT * FROM organization_members ${whereClause}
        ) t;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }
      
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const { cognito_user_id, full_name } = body;
        
        if (!cognito_user_id) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'cognito_user_id required' })
          };
        }
        
        // Update organization member full_name
        const sql = `
          UPDATE organization_members 
          SET full_name = '${full_name || ''}'
          WHERE cognito_user_id = '${cognito_user_id}'
          RETURNING *;
        `;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result })
        };
      }
    }

    // Profiles endpoint
    if (path.endsWith('/profiles')) {
      if (httpMethod === 'GET') {
        try {
          const { user_id } = event.queryStringParameters || {};
          let whereClause = '';
          
          if (user_id) {
            // Use formatSqlValue to safely escape user_id and prevent SQL injection
            const safeUserId = formatSqlValue(user_id);
            whereClause = `WHERE user_id = ${safeUserId}`;
          }
          
          const sql = `SELECT json_agg(row_to_json(t)) FROM (
            SELECT * FROM profiles ${whereClause}
          ) t;`;
          
          const result = await queryJSON(sql);
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
          };
        } catch (error) {
          console.error('Error fetching profiles:', error);
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Internal server error', message: error.message })
          };
        }
      }
      
      if (httpMethod === 'POST') {
        try {
          const body = JSON.parse(event.body || '{}');
          const { user_id, full_name, favorite_color } = body;
          
          if (!user_id) {
            return {
              statusCode: 400,
              headers,
              body: JSON.stringify({ error: 'user_id required' })
            };
          }
          
          // Use formatSqlValue to safely escape all values and prevent SQL injection
          const safeUserId = formatSqlValue(user_id);
          const safeFullName = formatSqlValue(full_name || '');
          const safeFavoriteColor = formatSqlValue(favorite_color);
          
          // Upsert profile
          const sql = `
            INSERT INTO profiles (user_id, full_name, favorite_color, updated_at) 
            VALUES (${safeUserId}, ${safeFullName}, ${safeFavoriteColor}, NOW())
            ON CONFLICT (user_id) 
            DO UPDATE SET 
              full_name = EXCLUDED.full_name,
              favorite_color = EXCLUDED.favorite_color,
              updated_at = NOW()
            RETURNING *;
          `;
          
          const result = await queryJSON(sql);
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ data: result })
          };
        } catch (error) {
          console.error('Error creating/updating profile:', error);
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Internal server error', message: error.message })
          };
        }
      }
    }

    // Checkins endpoint
    if (httpMethod === 'POST' && path.endsWith('/checkins')) {
      try {
        const body = JSON.parse(event.body || '{}');
        const afterImageArray = Array.isArray(body.after_image_urls)
          ? body.after_image_urls
          : body.after_image_urls
            ? [body.after_image_urls]
            : [];

        const insertData = {
          checkout_id: body.checkout_id,
          tool_id: body.tool_id,
          user_name: body.user_name || 'Unknown User',
          problems_reported: body.problems_reported !== undefined ? body.problems_reported : null,
          notes: body.notes !== undefined ? body.notes : null,
          sop_best_practices: body.sop_best_practices !== undefined ? body.sop_best_practices : '',
          what_did_you_do: body.what_did_you_do !== undefined ? body.what_did_you_do : '',
          checkin_reason: body.checkin_reason !== undefined ? body.checkin_reason : null,
          after_image_urls: afterImageArray,
          organization_id: (() => {
            if (!organizationId) {
              console.error('❌ ERROR: Cannot create checkin - organization_id is missing from authorizer context');
              throw new Error('Server configuration error: organization context not available');
            }
            return organizationId;
          })()
        };

        const requiredFields = ['checkout_id', 'tool_id', 'user_name'];
        const missingFields = requiredFields.filter(field => !insertData[field]);
        if (missingFields.length > 0) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: `Missing required fields: ${missingFields.join(', ')}` })
          };
        }

        const columns = Object.keys(insertData);
        const values = columns.map(col => formatSqlValue(insertData[col]));

        const sql = `
          INSERT INTO checkins (${columns.join(', ')}, checkin_date)
          VALUES (${values.join(', ')}, NOW())
          RETURNING *
        `;
        
        console.log('Checkin SQL:', sql);
        console.log('Checkin data:', JSON.stringify(insertData, null, 2));
        
        const result = await queryJSON(sql);
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      } catch (error) {
        console.error('Error creating checkin:', error);
        return {
          statusCode: 500,
          headers,
          body: JSON.stringify({ 
            error: 'Failed to create checkin',
            details: error.message,
            stack: error.stack
          })
        };
      }
    }

    // Checkouts endpoint
    if (path.endsWith('/checkouts') || path.match(/\/checkouts\/[a-f0-9-]+$/)) {
      if (httpMethod === 'DELETE') {
        const checkoutId = path.split('/').pop();
        const sql = `DELETE FROM checkouts WHERE id = '${checkoutId}' RETURNING *`;
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
      
      if (httpMethod === 'PUT') {
        const checkoutId = path.split('/').pop();
        const body = JSON.parse(event.body || '{}');
        const updates = [];
        if (body.checkout_date !== undefined) updates.push(`checkout_date = ${body.checkout_date ? `'${body.checkout_date}'` : 'NOW()'}`);
        if (body.is_returned !== undefined) updates.push(`is_returned = ${body.is_returned}`);
        if (updates.length === 0) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'No fields to update' })
          };
        }
        const sql = `UPDATE checkouts SET ${updates.join(', ')} WHERE id = '${checkoutId}' RETURNING *`;
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
      
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const { tool_id, user_id, user_name, intended_usage, notes, action_id, is_returned, checkout_date } = body;
        // Always use organizationId from authorizer context (not from request body)
        if (!organizationId) {
          console.error('❌ ERROR: Cannot create checkout - organization_id is missing from authorizer context');
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Server configuration error: organization context not available' })
          };
        }
        const orgId = organizationId;
        
        // Check for existing active checkout for this tool
        // An active checkout is one where is_returned = false
        const checkActiveCheckoutSql = `
          SELECT id, user_name, checkout_date 
          FROM checkouts 
          WHERE tool_id = '${tool_id}' 
            AND is_returned = false
            AND organization_id = '${orgId}'
          LIMIT 1
        `;
        const existingCheckouts = await queryJSON(checkActiveCheckoutSql);
        
        if (existingCheckouts && existingCheckouts.length > 0) {
          const existingCheckout = existingCheckouts[0];
          return {
            statusCode: 409,
            headers,
            body: JSON.stringify({ 
              error: 'Tool already has an active checkout',
              details: `This tool is currently checked out to ${existingCheckout.user_name || 'another user'}. Please return the tool before creating a new checkout.`,
              existing_checkout: {
                id: existingCheckout.id,
                user_name: existingCheckout.user_name,
                checkout_date: existingCheckout.checkout_date
              }
            })
          };
        }
        
        const checkoutDateValue = checkout_date ? `'${checkout_date}'` : (is_returned ? 'NOW()' : 'NULL');
        const sql = `
          INSERT INTO checkouts (tool_id, user_id, user_name, intended_usage, notes, action_id, organization_id, is_returned, checkout_date)
          VALUES ('${tool_id}', '${user_id}', '${user_name.replace(/'/g, "''")}', ${intended_usage ? `'${intended_usage.replace(/'/g, "''")}'` : 'NULL'}, ${notes ? `'${notes.replace(/'/g, "''")}'` : 'NULL'}, ${action_id ? `'${action_id}'` : 'NULL'}, '${orgId}', ${is_returned}, ${checkoutDateValue})
          RETURNING *
        `;
        
        try {
          const result = await queryJSON(sql);
          return {
            statusCode: 201,
            headers,
            body: JSON.stringify({ data: result[0] })
          };
        } catch (error) {
          // Catch duplicate key constraint violation
          if (error.message && error.message.includes('idx_unique_active_checkout_per_tool')) {
            return {
              statusCode: 409,
              headers,
              body: JSON.stringify({ 
                error: 'Tool already has an active checkout',
                details: 'This tool is currently checked out. Please return the tool before creating a new checkout.'
              })
            };
          }
          throw error;
        }
      }
      
      if (httpMethod === 'GET') {
        const { is_returned, action_id, tool_id } = event.queryStringParameters || {};
        let whereConditions = [];
        if (is_returned === 'false') {
          whereConditions.push('c.is_returned = false');
        } else if (is_returned === 'true') {
          whereConditions.push('c.is_returned = true');
        }
        if (action_id) {
          whereConditions.push(`c.action_id = '${action_id}'`);
        }
        if (tool_id) {
          whereConditions.push(`c.tool_id = '${tool_id}'`);
        }
        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT 
            c.*,
            t.serial_number as tool_serial_number,
            COALESCE(om.full_name, c.user_name) as user_name,
            a.title as action_title
          FROM checkouts c
          LEFT JOIN tools t ON c.tool_id = t.id
          LEFT JOIN organization_members om ON c.user_id = om.cognito_user_id
          LEFT JOIN actions a ON c.action_id = a.id
          ${whereClause} ORDER BY c.checkout_date DESC
        ) t;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }
    }

    // Missions endpoint
    if (path.endsWith('/missions')) {
      if (httpMethod === 'GET') {
        // Use same pattern as actions/parts - build organization filter to return everything user has access to
        const contextForFilter = {
          ...authContext,
          accessible_organization_ids: accessibleOrgIds,
          permissions: authContext.permissions || []
        };
        const orgFilter = buildOrganizationFilter(contextForFilter, 'm');
        
        // Build WHERE clause - empty condition means user has data:read:all permission (return all), 
        // otherwise filter by accessible orgs
        const whereClause = orgFilter.condition ? `WHERE ${orgFilter.condition}` : '';
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT * FROM missions m ${whereClause} ORDER BY created_at DESC
        ) t;`;
        
        // Enhanced logging for debugging
        console.log('Missions GET endpoint:', {
          path,
          organization_id: organizationId,
          accessible_orgs: accessibleOrgIds,
          accessible_orgs_count: accessibleOrgIds.length,
          has_data_read_all: hasDataReadAll,
          permissions: authContext.permissions,
          orgFilter_condition: orgFilter.condition,
          whereClause: whereClause,
          sql: sql.substring(0, 300)
        });
        
        try {
          const result = await queryJSON(sql);
          const missions = result?.[0]?.json_agg || [];
          
          console.log('Missions query result:', {
            result_type: typeof result,
            result_length: result?.length,
            json_agg_type: typeof result?.[0]?.json_agg,
            missions_count: missions.length,
            first_mission_org_id: missions[0]?.organization_id || 'none',
            first_mission_title: missions[0]?.title || 'none'
          });
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ data: missions })
          };
        } catch (error) {
          console.error('❌ ERROR: Failed to query missions:', error);
          console.error('   SQL:', sql);
          console.error('   Error details:', error.message, error.stack);
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ 
              error: 'Failed to fetch missions',
              message: error.message 
            })
          };
        }
      }
      
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const { 
          title, 
          problem_statement, 
          created_by, 
          qa_assigned_to,
          template_id,
          template_name,
          template_color,
          template_icon,
          organization_id
        } = body;
        
        if (!title || !created_by) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'title and created_by are required' })
          };
        }
        
        // Map Cognito user ID to database user_id if needed
        let dbUserId = created_by;
        if (created_by.includes('-')) {
          // If it looks like a UUID, assume it's already a database user_id
          dbUserId = created_by;
        } else {
          // If it's a Cognito user ID, look up the database user_id
          const userLookupSql = `SELECT user_id FROM organization_members WHERE cognito_user_id = '${created_by}' LIMIT 1;`;
          const userResult = await queryJSON(userLookupSql);
          if (userResult && userResult.length > 0) {
            dbUserId = userResult[0].user_id;
          } else {
            return {
              statusCode: 400,
              headers,
              body: JSON.stringify({ error: 'User not found in organization' })
            };
          }
        }
        
        // Map qa_assigned_to if provided
        let dbQaUserId = qa_assigned_to;
        if (qa_assigned_to && !qa_assigned_to.includes('-')) {
          const qaUserLookupSql = `SELECT user_id FROM organization_members WHERE cognito_user_id = '${qa_assigned_to}' LIMIT 1;`;
          const qaUserResult = await queryJSON(qaUserLookupSql);
          if (qaUserResult && qaUserResult.length > 0) {
            dbQaUserId = qaUserResult[0].user_id;
          }
        }
        
        // Always use organizationId from authorizer context (not from request body)
        // This ensures security - users can't create resources in organizations they don't belong to
        if (!organizationId) {
          console.error('❌ ERROR: Cannot create mission - organization_id is missing from authorizer context');
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: 'Server configuration error: organization context not available' })
          };
        }
        const orgId = organizationId;
        
        // Include organization_id in INSERT
        const sql = `
          INSERT INTO missions (
            title, 
            problem_statement, 
            created_by, 
            qa_assigned_to,
            organization_id,
            status, 
            template_id,
            template_name,
            template_color,
            template_icon,
            created_at, 
            updated_at
          ) VALUES (
            '${title.replace(/'/g, "''")}', 
            '${(problem_statement || '').replace(/'/g, "''")}', 
            '${dbUserId}', 
            ${dbQaUserId ? `'${dbQaUserId}'` : 'NULL'},
            '${orgId}',
            'planning',
            ${template_id ? `'${template_id}'` : 'NULL'},
            ${template_name ? `'${template_name.replace(/'/g, "''")}'` : 'NULL'},
            ${template_color ? `'${template_color}'` : 'NULL'},
            ${template_icon ? `'${template_icon}'` : 'NULL'},
            NOW(), 
            NOW()
          )
          RETURNING *;
        `;
        
        console.log('SQL:', sql);
        const result = await queryJSON(sql);
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
    }

    // Missions by ID endpoint (GET, PUT, DELETE)
    if (path.includes('/missions/') && !path.endsWith('/missions')) {
      const missionId = path.split('/missions/')[1]?.split('/')[0]; // Extract ID, handle trailing paths
      
      if (httpMethod === 'GET') {
        const orgFilter = buildOrganizationFilter(authContext, 'm');
        const whereClause = orgFilter.condition ? `WHERE m.id = '${missionId}' AND ${orgFilter.condition}` : `WHERE m.id = '${missionId}'`;
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT * FROM missions m ${whereClause}
        ) t;`;
        
        const result = await queryJSON(sql);
        const mission = result?.[0]?.json_agg?.[0];
        
        if (!mission) {
          return {
            statusCode: 404,
            headers,
            body: JSON.stringify({ error: 'Mission not found' })
          };
        }
        
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: mission })
        };
      }
      
      if (httpMethod === 'PUT') {
        const body = JSON.parse(event.body || '{}');
        const { id, created_by, created_at, updated_at, ...missionData } = body;
        
        // Build UPDATE statement
        const updates = [];
        for (const [key, val] of Object.entries(missionData)) {
          if (val === undefined) continue;
          if (val === null) updates.push(`${key} = NULL`);
          else if (typeof val === 'string') updates.push(`${key} = '${val.replace(/'/g, "''")}'`);
          else if (typeof val === 'boolean') updates.push(`${key} = ${val}`);
          else updates.push(`${key} = ${val}`);
        }
        updates.push(`updated_at = NOW()`);
        
        const orgFilter = buildOrganizationFilter(authContext, 'm');
        const whereClause = orgFilter.condition 
          ? `WHERE id = '${missionId}' AND ${orgFilter.condition}`
          : `WHERE id = '${missionId}'`;
        
        const sql = `UPDATE missions SET ${updates.join(', ')} ${whereClause} RETURNING *;`;
        const result = await queryJSON(sql);
        
        if (!result || result.length === 0) {
          return {
            statusCode: 404,
            headers,
            body: JSON.stringify({ error: 'Mission not found' })
          };
        }
        
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
      
      if (httpMethod === 'DELETE') {
        const orgFilter = buildOrganizationFilter(authContext, 'm');
        const whereClause = orgFilter.condition 
          ? `WHERE id = '${missionId}' AND ${orgFilter.condition}`
          : `WHERE id = '${missionId}'`;
        
        const sql = `DELETE FROM missions ${whereClause} RETURNING id;`;
        const result = await queryJSON(sql);
        
        if (!result || result.length === 0) {
          return {
            statusCode: 404,
            headers,
            body: JSON.stringify({ error: 'Mission not found' })
          };
        }
        
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: { id: result[0].id } })
        };
      }
    }

    // Actions endpoint with full details
    if (httpMethod === 'GET' && path.endsWith('/actions')) {
      const { limit, offset = 0, assigned_to, status, id, linked_issue_id } = event.queryStringParameters || {};
      
      let whereConditions = [];
      if (id) {
        whereConditions.push(`a.id = '${id}'`);
      }
      if (assigned_to) {
        whereConditions.push(`a.assigned_to = '${assigned_to}'`);
      }
      if (linked_issue_id) {
        whereConditions.push(`a.linked_issue_id = '${escapeLiteral(linked_issue_id)}'`);
      }
      if (status) {
        if (status === 'unresolved') {
          whereConditions.push(`a.status IN ('not_started', 'in_progress', 'blocked')`);
        } else {
          whereConditions.push(`a.status = '${status}'`);
        }
      }
      
      const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
      const limitClause = limit ? `LIMIT ${limit} OFFSET ${offset}` : '';
      
      const sql = `SELECT json_agg(row_to_json(t)) FROM (
        SELECT 
          a.*,
          om.full_name as assigned_to_name,
          om.favorite_color as assigned_to_color,
          CASE WHEN scores.action_id IS NOT NULL THEN true ELSE false END as has_score,
          CASE WHEN updates.action_id IS NOT NULL THEN true ELSE false END as has_implementation_updates,
          COALESCE(update_counts.count, 0) as implementation_update_count,
          -- Asset details
          CASE WHEN a.asset_id IS NOT NULL THEN
            json_build_object(
              'id', assets.id,
              'name', assets.name,
              'category', assets.category
            )
          END as asset,
          -- Issue tool details  
          CASE WHEN a.issue_tool_id IS NOT NULL THEN
            json_build_object(
              'id', issue_tools.id,
              'name', issue_tools.name,
              'category', issue_tools.category
            )
          END as issue_tool,
          -- Mission details
          CASE WHEN a.mission_id IS NOT NULL THEN
            json_build_object(
              'id', missions.id,
              'title', missions.title,
              'mission_number', missions.mission_number
            )
          END as mission,
          -- Participants details
          CASE WHEN participants.participants IS NOT NULL THEN
            participants.participants
          END as participants_details
        FROM actions a
        LEFT JOIN profiles om ON a.assigned_to = om.user_id
        LEFT JOIN action_scores scores ON a.id = scores.action_id
        LEFT JOIN (
          SELECT DISTINCT action_id 
          FROM action_implementation_updates
          WHERE update_type != 'policy_agreement' OR update_type IS NULL
        ) updates ON a.id = updates.action_id
        LEFT JOIN (
          SELECT action_id, COUNT(*) as count
          FROM action_implementation_updates
          WHERE update_type != 'policy_agreement' OR update_type IS NULL
          GROUP BY action_id
        ) update_counts ON a.id = update_counts.action_id
        LEFT JOIN tools assets ON a.asset_id = assets.id
        LEFT JOIN tools issue_tools ON a.issue_tool_id = issue_tools.id
        LEFT JOIN missions ON a.mission_id = missions.id
        LEFT JOIN (
          SELECT 
            ap.action_id,
            json_agg(
              json_build_object(
                'user_id', om_part.user_id,
                'full_name', om_part.full_name,
                'favorite_color', om_part.favorite_color
              )
            ) as participants
          FROM action_participants ap
          LEFT JOIN profiles om_part ON ap.user_id = om_part.user_id
          GROUP BY ap.action_id
        ) participants ON a.id = participants.action_id
        ${whereClause} 
        ORDER BY a.updated_at DESC 
        ${limitClause}
      ) t;`;
      
      const result = await queryJSON(sql);
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
      };
    }

    // POST /actions - Create new action
    if (httpMethod === 'POST' && path.endsWith('/actions')) {
      const body = JSON.parse(event.body || '{}');
      
      if (!body.title) {
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ error: 'title is required' })
        };
      }

      const actionId = body.id || randomUUID();
      const now = new Date().toISOString();
      
      // Build the INSERT statement
      const insertFields = [
        'id',
        'title',
        'description',
        'policy',
        'assigned_to',
        'status',
        'estimated_duration',
        'required_stock',
        'attachments',
        'mission_id',
        'asset_id',
        'linked_issue_id',
        'issue_reference',
        'plan_commitment',
        'policy_agreed_at',
        'policy_agreed_by',
        'organization_id',
        'created_by',
        'updated_by',
        'created_at',
        'updated_at'
      ];

      const insertValues = [
        formatSqlValue(actionId),
        formatSqlValue(body.title),
        formatSqlValue(body.description),
        formatSqlValue(body.policy),
        formatSqlValue(body.assigned_to),
        formatSqlValue(body.status || 'not_started'),
        formatSqlValue(body.estimated_duration),
        formatSqlValue(body.required_stock),
        formatSqlValue(body.attachments || []),
        formatSqlValue(body.mission_id),
        formatSqlValue(body.asset_id),
        formatSqlValue(body.linked_issue_id),
        formatSqlValue(body.issue_reference),
        formatSqlValue(body.plan_commitment),
        formatSqlValue(body.policy_agreed_at),
        formatSqlValue(body.policy_agreed_by),
        (() => {
          if (!organizationId) {
            console.error('❌ ERROR: Cannot create action - organization_id is missing from authorizer context');
            throw new Error('Server configuration error: organization context not available');
          }
          return formatSqlValue(organizationId);
        })(),
        formatSqlValue(body.created_by),
        formatSqlValue(body.updated_by),
        formatSqlValue(now),
        formatSqlValue(now)
      ];

      const client = new Client(dbConfig);
      try {
        await client.connect();
        await client.query('BEGIN');

        // Insert the action
        const insertSql = `
          INSERT INTO actions (${insertFields.join(', ')})
          VALUES (${insertValues.join(', ')})
          RETURNING id
        `;
        
        console.log('Insert SQL:', insertSql);
        console.log('Insert values:', JSON.stringify(insertValues, null, 2));
        console.log('Body data:', JSON.stringify(body, null, 2));
        
        let insertResult;
        try {
          insertResult = await client.query(insertSql);
        } catch (sqlError) {
          console.error('SQL Error:', sqlError.message);
          console.error('SQL Query:', insertSql);
          console.error('Insert Fields:', insertFields);
          console.error('Insert Values (raw):', insertValues);
          // Return error with SQL for debugging
          await client.query('ROLLBACK');
          await client.end();
          return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ 
              error: sqlError.message,
              sql: insertSql,
              fields: insertFields,
              values: insertValues
            })
          };
        }
        const newActionId = insertResult.rows[0].id;

        // Handle participants if provided
        if (body.participants && Array.isArray(body.participants) && body.participants.length > 0) {
          const participantValues = body.participants.map(userId => 
            `('${escapeLiteral(newActionId)}', '${escapeLiteral(userId)}')`
          ).join(', ');
          
          const participantsSql = `
            INSERT INTO action_participants (action_id, user_id)
            VALUES ${participantValues}
            ON CONFLICT (action_id, user_id) DO NOTHING
          `;
          await client.query(participantsSql);
        }

        await client.query('COMMIT');

        // Fetch the created action with all joins
        const fetchSql = `
          SELECT json_agg(row_to_json(t)) FROM (
            SELECT 
              a.*,
              om.full_name as assigned_to_name,
              om.favorite_color as assigned_to_color,
              CASE WHEN participants.participants IS NOT NULL THEN
                participants.participants
              END as participants_details
            FROM actions a
            LEFT JOIN profiles om ON a.assigned_to = om.user_id
            LEFT JOIN (
              SELECT 
                ap.action_id,
                json_agg(
                  json_build_object(
                    'user_id', om_part.user_id,
                    'full_name', om_part.full_name,
                    'favorite_color', om_part.favorite_color
                  )
                ) as participants
              FROM action_participants ap
              LEFT JOIN profiles om_part ON ap.user_id = om_part.user_id
              WHERE ap.action_id = '${escapeLiteral(newActionId)}'
              GROUP BY ap.action_id
            ) participants ON a.id = participants.action_id
            WHERE a.id = '${escapeLiteral(newActionId)}'
          ) t;
        `;
        
        const fetchResult = await queryJSON(fetchSql);
        
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: fetchResult?.[0]?.json_agg?.[0] || null })
        };
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        await client.end();
      }
    }

    // Action implementation updates endpoint
    if (path.endsWith('/action_implementation_updates')) {
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const { action_id, update_text, updated_by } = body;
        
        if (!action_id || !update_text || !updated_by) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'action_id, update_text, and updated_by are required' })
          };
        }
        
        const sql = `
          INSERT INTO action_implementation_updates (action_id, update_text, updated_by)
          VALUES ('${action_id}', '${update_text.replace(/'/g, "''")}', '${updated_by}')
          RETURNING *
        `;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
      
      if (httpMethod === 'GET') {
        const { action_id, limit = 50 } = event.queryStringParameters || {};
        
        if (!action_id) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'action_id parameter required' })
          };
        }
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT 
            aiu.*,
            om.full_name as updated_by_name,
            om.favorite_color as updated_by_color
          FROM action_implementation_updates aiu
          LEFT JOIN profiles om ON aiu.updated_by = om.user_id
          WHERE aiu.action_id = '${action_id}' 
          ORDER BY aiu.created_at DESC 
          LIMIT ${limit}
        ) t;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }
    }

    // Action scores endpoint
    if (path.endsWith('/action_scores')) {
      if (httpMethod === 'GET') {
        const { asset_context_id, source_id, source_type } = event.queryStringParameters || {};
        let whereConditions = [];
        if (asset_context_id) whereConditions.push(`asset_context_id = '${escapeLiteral(asset_context_id)}'`);
        if (source_id) whereConditions.push(`source_id = '${escapeLiteral(source_id)}'`);
        if (source_type) whereConditions.push(`source_type = '${escapeLiteral(source_type)}'`);
        const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';
        
        const sql = `SELECT json_agg(row_to_json(t)) FROM (
          SELECT * FROM action_scores ${whereClause} ORDER BY created_at DESC
        ) t;`;
        
        const result = await queryJSON(sql);
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({ data: result?.[0]?.json_agg || [] })
        };
      }
      
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const insertData = {
          id: body.id || randomUUID(),
          action_id: body.action_id,
          asset_context_id: body.asset_context_id,
          asset_context_name: body.asset_context_name,
          source_type: body.source_type,
          source_id: body.source_id,
          prompt_id: body.prompt_id,
          prompt_text: body.prompt_text,
          scores: body.scores,
          ai_response: body.ai_response || null,
          likely_root_causes: body.likely_root_causes || null,
          score_attribution_type: body.score_attribution_type || 'action'
        };
        
        const columns = Object.keys(insertData);
        const values = columns.map(col => formatSqlValue(insertData[col]));
        
        const sql = `INSERT INTO action_scores (${columns.join(', ')}, created_at, updated_at) VALUES (${values.join(', ')}, NOW(), NOW()) RETURNING *`;
        const result = await queryJSON(sql);
        return {
          statusCode: 201,
          headers,
          body: JSON.stringify({ data: result[0] })
        };
      }
    }
    
    // Scoring prompts endpoint
    if (path.endsWith('/scoring_prompts')) {
      if (httpMethod === 'GET') {
        const sql = `SELECT json_agg(row_to_json(t)) FROM (SELECT * FROM scoring_prompts ORDER BY created_at DESC) t;`;
        const result = await queryJSON(sql);
        return { statusCode: 200, headers, body: JSON.stringify({ data: result?.[0]?.json_agg || [] }) };
      }
      if (httpMethod === 'POST') {
        const body = JSON.parse(event.body || '{}');
        const sql = `INSERT INTO scoring_prompts (name, prompt_text, is_default, created_by) VALUES (${formatSqlValue(body.name)}, ${formatSqlValue(body.prompt_text)}, ${body.is_default || false}, ${formatSqlValue(body.created_by)}) RETURNING *`;
        const result = await queryJSON(sql);
        return { statusCode: 201, headers, body: JSON.stringify({ data: result[0] }) };
      }
    }
    
    if (path.match(/\/scoring_prompts\/[a-f0-9-]+$/)) {
      const promptId = path.split('/').pop();
      if (httpMethod === 'PUT') {
        const body = JSON.parse(event.body || '{}');
        const updates = buildUpdateClauses(body, ['name', 'prompt_text', 'is_default']);
        if (updates.length === 0) return { statusCode: 400, headers, body: JSON.stringify({ error: 'No fields to update' }) };
        updates.push('updated_at = NOW()');
        const sql = `UPDATE scoring_prompts SET ${updates.join(', ')} WHERE id = '${promptId}' RETURNING *`;
        const result = await queryJSON(sql);
        return { statusCode: 200, headers, body: JSON.stringify({ data: result[0] }) };
      }
    }
    
    if (path.match(/\/scoring_prompts\/[a-f0-9-]+\/set-default$/)) {
      const promptId = path.split('/')[path.split('/').length - 2];
      if (httpMethod === 'PUT') {
        await queryJSON(`UPDATE scoring_prompts SET is_default = false`);
        await queryJSON(`UPDATE scoring_prompts SET is_default = true WHERE id = '${promptId}'`);
        return { statusCode: 200, headers, body: JSON.stringify({ success: true }) };
      }
    }
    
    // Action scores by ID
    if (path.match(/\/action_scores\/[a-f0-9-]+$/)) {
      const scoreId = path.split('/').pop();
      
      if (httpMethod === 'PUT') {
        const body = JSON.parse(event.body || '{}');
        const updates = buildUpdateClauses(body, ['scores', 'ai_response', 'likely_root_causes']);
        if (updates.length === 0) {
          return { statusCode: 400, headers, body: JSON.stringify({ error: 'No fields to update' }) };
        }
        updates.push('updated_at = NOW()');
        const sql = `UPDATE action_scores SET ${updates.join(', ')} WHERE id = '${scoreId}' RETURNING *`;
        const result = await queryJSON(sql);
        return { statusCode: 200, headers, body: JSON.stringify({ data: result[0] }) };
      }
    }

    // Default 404
    return {
      statusCode: 404,
      headers,
      body: JSON.stringify({ error: 'Not found' })
    };

  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({ error: error.message })
    };
  }
};